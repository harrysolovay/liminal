# Liminal Messages <Badge type="warning" text="beta" />

Liminal provides a model-agnostic interface for `Message`.

## Interoperability

Whenever we send conversations to a given model, an adapter is responsible for
transforming the conversation's messages into the Model-specific formats. A
consistent `Message` interface spares us of issues with model interoperability.

In the following code, for example, we need not worry about the possibility of
the agent consumer binding to message-incompatible models.

```ts
function* g() {
  yield* L.model("A")
  yield* L.user`User message A.`
  yield* L.infer

  yield* L.model("B")
  yield* L.user`User message B.`
  yield* L.infer
}
```

## Message Roles and Contents

There are four roles, each with their own shape of `content`s.

| Role        | Description                                                                                                                         | Content            |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------- | ------------------ |
| `system`    | Provides key instructions to which models should adhere.                                                                            | `SystemMessage`    |
| `user`      | Messages provided to (but not generated by) the model (such as prompts, documents and user input).                                  | `UserMessage`      |
| `assistant` | Usually generated by the assistant in response to previous messages. Potentially "seeded" [^1] values to inform model behavior.     | `AssistantMessage` |
| `tool`      | Generated within a tool-calling loop. These are typically excluded from the conversation once the tool-calling loop has terminated. | `ToolMessage`      |

## Reading Messages

To access the current conversation, we can extract it from a snapshot of the
agent state.

```ts
function* g() {
  const { messages } = yield* L.snapshot

  messages satisfies Set<Message>
}
```

## Appending Messages

```ts
function* g() {
  yield* L.$system`Message A.`
  yield* L.$user`Message A.`
  yield* L.$assistant`Message A.`
  yield* L.$tool`Message A.`
}
```

## Handles

Whenever we create a message, the executor will return to us a `Handle<Message>`
with which we can do various operations, such as ultimately removing it from the
conversation.

```ts
function* g() {
  const handle = yield* L.system`Message A.`

  yield* L.ensureRemoved(handle)
}
```

## Conversation Slices

[^1]: [LLM assistant message seeding](https://padolsey.medium.com/simple-llm-gpt-trick-seeding-08fbcc1880c7)
