# Liminal Messages <Badge type="warning" text="beta" />

Liminal provides a model-agnostic interface for `Message`.

## Interoperability

Whenever we send conversations to a given model, an adapter is responsible for
transforming the agent's messages into the Model-specific format. This
consistent `Message` interface spares us of issues with model interoperability.

In the following code, for example, we need not worry about the possibility of
the model "A" and "B" requiring different representations of the message list.

```ts
function* g() {
  yield* L.model("A")
  yield* L.user`User message A.`
  yield* L.infer

  yield* L.model("B")
  yield* L.user`User message B.`
  yield* L.infer
}
```

## Message Roles and Contents

There are three roles, each with their own shape of `content`s.

| Role        | Description                                                                                                                     | Content            |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------- | ------------------ |
| `system`    | Provides key instructions to which models should adhere.                                                                        | `SystemMessage`    |
| `user`      | Messages provided to (but not generated by) the model (such as prompts, documents and user input).                              | `UserMessage`      |
| `assistant` | Usually generated by the assistant in response to previous messages. Potentially "seeded" [^1] values to inform model behavior. | `AssistantMessage` |

> Note: Liminal does not treat tool messages as core messages; rather they are a
> provider-specific implementation detail and should not make their way into the
> agent's message list.

## Reading Messages

To access the current conversation, we can extract it from a snapshot of the
agent state.

```ts
function* g() {
  const messages = yield* L.messages

  messages satisfies Set<Message>
}
```

## Appending Messages

```ts
function* g() {
  yield* L.system`Message A.`
  yield* L.user`Message A.`
  yield* L.assistant`Message A.`
}
```

## Handles

When we yield message-related directives, the message itself is returned. We can
use the message object for various operations, such as removing it from the
conversation.

```ts
function* g() {
  const message = yield* L.system`Message A.`

  yield* message.forget
}
```

## Conversation Slices

[^1]: [LLM assistant message seeding](https://padolsey.medium.com/simple-llm-gpt-trick-seeding-08fbcc1880c7)
